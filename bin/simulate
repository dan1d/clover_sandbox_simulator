#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "clover_sandbox_simulator"
require "thor"

module CloverSandboxSimulator
  # Command-line interface for Clover Sandbox Simulator
  class CLI < Thor
    class_option :verbose, type: :boolean, aliases: "-v", desc: "Enable verbose logging"
    class_option :merchant, type: :string, aliases: "-m", desc: "Merchant ID to use (from .env.json)"
    class_option :merchant_index, type: :numeric, aliases: "-i", desc: "Merchant index to use (0-based, from .env.json)"

    desc "merchants", "List available merchants from .env.json"
    def merchants
      puts "ğŸ½ï¸  Clover Sandbox Simulator - Available Merchants"
      puts "=" * 60

      config = CloverSandboxSimulator.configuration
      merchants = config.available_merchants

      if merchants.empty?
        puts "No merchants found in .env.json"
        return
      end

      puts "\n#{'Index'.ljust(6)} #{'Merchant ID'.ljust(16)} #{'Name'.ljust(25)} #{'eComm'}"
      puts "-" * 60

      merchants.each_with_index do |m, idx|
        ecomm = m[:has_ecommerce] ? "âœ“" : "-"
        puts "#{idx.to_s.ljust(6)} #{m[:id].ljust(16)} #{m[:name][0..23].ljust(25)} #{ecomm}"
      end

      puts "\nUse: simulate <command> -i <index> or -m <merchant_id>"
    end

    desc "setup", "Set up restaurant entities (categories, items, discounts, employees, customers)"
    option :business_type, type: :string, default: "restaurant", desc: "Business type (restaurant, retail, salon)"
    def setup
      configure_logging

      puts "ğŸ½ï¸  Clover Sandbox Simulator - Entity Setup"
      puts "=" * 50

      generator = Generators::EntityGenerator.new(business_type: options[:business_type].to_sym)
      generator.setup_all

      puts "\nâœ… Setup complete!"
    end

    desc "generate", "Generate orders for today"
    option :count, type: :numeric, aliases: "-n", desc: "Number of orders to generate"
    option :refund_percentage, type: :numeric, aliases: "-r", default: 5,
           desc: "Percentage of orders to refund (0-100, default 5)"
    def generate
      configure_logging

      puts "ğŸ½ï¸  Clover Sandbox Simulator - Order Generation"
      puts "=" * 50

      generator = Generators::OrderGenerator.new(refund_percentage: options[:refund_percentage])
      count = options[:count]

      orders = generator.generate_today(count: count)

      puts "\nâœ… Generated #{orders.size} orders!"
    end

    desc "day", "Generate a realistic full day of restaurant operations"
    option :multiplier, type: :numeric, aliases: "-x", default: 1.0, desc: "Order multiplier (0.5 = slow day, 2.0 = busy day)"
    option :refund_percentage, type: :numeric, aliases: "-r", default: 5,
           desc: "Percentage of orders to refund (0-100, default 5)"
    def day
      configure_logging

      puts "ğŸ½ï¸  Clover Sandbox Simulator - Realistic Restaurant Day"
      puts "=" * 50

      generator = Generators::OrderGenerator.new(refund_percentage: options[:refund_percentage])
      orders = generator.generate_realistic_day(multiplier: options[:multiplier])

      puts "\nâœ… Generated #{orders.size} orders!"
    end

    desc "rush", "Generate a lunch or dinner rush"
    option :period, type: :string, aliases: "-p", default: "dinner", desc: "Meal period (breakfast, lunch, happy_hour, dinner, late_night)"
    option :count, type: :numeric, aliases: "-n", default: 15, desc: "Number of orders"
    def rush
      configure_logging

      period = options[:period].to_sym
      count = options[:count]

      puts "ğŸ½ï¸  Clover Sandbox Simulator - #{period.to_s.upcase} Rush"
      puts "=" * 50

      generator = Generators::OrderGenerator.new
      data = generator.send(:fetch_required_data)

      unless data
        puts "âŒ Failed to fetch data. Run setup first."
        return
      end

      orders = []
      count.times do |i|
        order = generator.send(:create_realistic_order,
          period: period,
          data: data,
          order_num: i + 1,
          total_in_period: count
        )

        if order
          orders << order
          generator.send(:update_stats, order, period)
        end
      end

      generator.send(:print_summary)
      puts "\nâœ… Generated #{orders.size} #{period} orders!"
    end

    desc "full", "Run full simulation (setup + generate orders)"
    option :count, type: :numeric, aliases: "-n", desc: "Number of orders to generate"
    option :business_type, type: :string, default: "restaurant", desc: "Business type"
    option :refund_percentage, type: :numeric, aliases: "-r", default: 5,
           desc: "Percentage of orders to refund (0-100, default 5)"
    def full
      configure_logging

      puts "ğŸ½ï¸  Clover Sandbox Simulator - Full Simulation"
      puts "=" * 50

      # Setup entities
      entity_gen = Generators::EntityGenerator.new(business_type: options[:business_type].to_sym)
      entity_gen.setup_all

      puts "\n"

      # Generate orders
      order_gen = Generators::OrderGenerator.new(refund_percentage: options[:refund_percentage])
      orders = order_gen.generate_today(count: options[:count])

      puts "\nâœ… Full simulation complete!"
      puts "   Orders generated: #{orders.size}"
    end

    desc "delete", "Delete all entities (use with caution!)"
    option :confirm, type: :boolean, desc: "Confirm deletion"
    def delete
      unless options[:confirm]
        puts "âš ï¸  This will delete ALL entities from Clover!"
        puts "   Run with --confirm to proceed."
        return
      end

      configure_logging

      puts "ğŸ—‘ï¸  Deleting all entities..."

      generator = Generators::EntityGenerator.new
      generator.delete_all

      puts "\nâœ… All entities deleted!"
    end

    desc "reset_orders", "Delete all orders (keeps menu items, employees, etc.)"
    option :confirm, type: :boolean, desc: "Confirm deletion"
    option :today_only, type: :boolean, default: true, desc: "Only delete today's orders (default: true)"
    def reset_orders
      unless options[:confirm]
        puts "âš ï¸  This will delete all orders from Clover!"
        puts "   Your menu items, employees, customers, and other entities will be kept."
        puts "   Run with --confirm to proceed."
        return
      end

      configure_logging

      puts "ğŸ—‘ï¸  Clover Sandbox Simulator - Reset Orders"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      # First, show what will be deleted
      if options[:today_only]
        puts "Deleting today's orders..."
        count = services.order.delete_orders_since
      else
        puts "Deleting ALL orders..."
        count = services.order.delete_all_orders
      end

      puts "\nâœ… Deleted #{count} orders!"
      puts "   Your menu, employees, and customers are still intact."
      puts "   Run 'simulate generate' to create new orders."
    end

    desc "orders", "List recent orders"
    option :limit, type: :numeric, aliases: "-l", default: 20, desc: "Number of orders to show"
    def orders
      configure_logging

      puts "ğŸ“‹ Clover Sandbox Simulator - Recent Orders"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new
      orders = services.order.get_orders(limit: options[:limit])

      if orders.empty?
        puts "No orders found."
        puts "\nRun 'simulate generate' to create orders."
        return
      end

      puts "\nFound #{orders.size} orders:\n\n"

      total_revenue = 0
      orders.each do |order|
        created = order["createdTime"] ? Time.at(order["createdTime"] / 1000).strftime("%H:%M:%S") : "N/A"
        total = order["total"] || 0
        total_revenue += total
        state = order["state"] || "unknown"
        title = order["title"] || "Order"

        state_emoji = case state
                      when "open" then "ğŸŸ¡"
                      when "locked" then "ğŸ”’"
                      when "paid" then "âœ…"
                      else "âšª"
                      end

        puts "#{state_emoji} #{title} | $#{'%.2f' % (total / 100.0)} | #{created} | #{order['id']}"
      end

      puts "\n" + "-" * 50
      puts "Total: $#{'%.2f' % (total_revenue / 100.0)} across #{orders.size} orders"
    end

    desc "status", "Show current Clover merchant status"
    def status
      configure_logging

      puts "ğŸ½ï¸  Clover Sandbox Simulator - Status"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      categories = services.inventory.get_categories
      items = services.inventory.get_items
      tenders = services.tender.get_safe_tenders
      employees = services.employee.get_employees
      customers = services.customer.get_customers
      discounts = services.discount.get_discounts
      refunds = services.refund.fetch_refunds
      modifier_groups = services.inventory.get_modifier_groups
      order_types = services.order_type.get_order_types
      tax_rates = services.tax.get_tax_rates

      # Fetch active shifts (may fail gracefully)
      active_shifts = begin
        services.shift.get_active_shifts
      rescue StandardError
        []
      end

      # Fetch service charges (may not be supported)
      service_charges = begin
        services.service_charge.get_service_charges
      rescue StandardError
        []
      end

      puts "\nğŸ“Š Entity Counts:"
      puts "   Categories:       #{categories.size}"
      puts "   Menu Items:       #{items.size}"
      puts "   Modifier Groups:  #{modifier_groups.size}"
      puts "   Tax Rates:        #{tax_rates.size}"
      puts "   Order Types:      #{order_types.size}"
      puts "   Discounts:        #{discounts.size}"
      puts "   Employees:        #{employees.size}"
      puts "   Customers:        #{customers.size}"
      puts "   Tenders:          #{tenders.size} (sandbox-safe)"
      puts "   Refunds:          #{refunds.size}"
      puts "   Service Charges:  #{service_charges.size}"
      puts "   Active Shifts:    #{active_shifts.size}"

      puts "\nğŸ“‹ Categories:"
      categories.each { |c| puts "   - #{c['name']}" }

      puts "\nğŸ” Modifier Groups:"
      modifier_groups.each do |mg|
        modifier_count = mg.dig("modifiers", "elements")&.size || 0
        puts "   - #{mg['name']} (#{modifier_count} modifiers)"
      end

      puts "\nğŸ“ Order Types:"
      order_types.each { |ot| puts "   - #{ot['label']}" }

      puts "\nğŸ’° Tax Rates:"
      tax_rates.each do |tr|
        rate_pct = (tr["rate"] || 0) / 100_000.0
        default_marker = tr["isDefault"] ? " (default)" : ""
        puts "   - #{tr['name']}: #{rate_pct}%#{default_marker}"
      end

      puts "\nğŸ’³ Safe Tenders (no credit/debit):"
      tenders.each { |t| puts "   - #{t['label']}" }
    end

    desc "refunds", "List all refunds"
    option :limit, type: :numeric, aliases: "-l", desc: "Maximum number of refunds to show"
    def refunds
      configure_logging

      puts "ğŸ½ï¸  Clover Sandbox Simulator - Refunds"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new
      refunds = services.refund.fetch_refunds(limit: options[:limit])

      if refunds.empty?
        puts "No refunds found."
        return
      end

      puts "Found #{refunds.size} refunds:\n\n"

      total_amount = 0
      refunds.each do |refund|
        amount = refund["amount"] || 0
        total_amount += amount
        payment_id = refund.dig("payment", "id") || "N/A"
        created_at = refund["createdTime"] ? Time.at(refund["createdTime"] / 1000).strftime("%Y-%m-%d %H:%M") : "N/A"

        puts "  ID: #{refund['id']}"
        puts "     Amount:     $#{'%.2f' % (amount / 100.0)}"
        puts "     Payment:    #{payment_id}"
        puts "     Created:    #{created_at}"
        puts ""
      end

      puts "-" * 40
      puts "Total refunded: $#{'%.2f' % (total_amount / 100.0)}"
    end

    desc "refund", "Create a refund for a payment"
    option :payment_id, type: :string, aliases: "-p", required: true, desc: "Payment ID to refund"
    option :amount, type: :numeric, aliases: "-a", desc: "Amount in cents (omit for full refund)"
    option :reason, type: :string, aliases: "-r", default: "customer_request",
           desc: "Refund reason (customer_request, quality_issue, wrong_order, duplicate_charge)"
    def refund
      configure_logging

      puts "ğŸ½ï¸  Clover Sandbox Simulator - Create Refund"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      if options[:amount]
        puts "Creating partial refund of $#{'%.2f' % (options[:amount] / 100.0)}..."
        result = services.refund.create_partial_refund(
          payment_id: options[:payment_id],
          amount: options[:amount],
          reason: options[:reason]
        )
      else
        puts "Creating full refund..."
        result = services.refund.create_full_refund(
          payment_id: options[:payment_id],
          reason: options[:reason]
        )
      end

      if result && result["id"]
        puts "\nâœ… Refund created successfully!"
        puts "   Refund ID: #{result['id']}"
        puts "   Amount:    $#{'%.2f' % ((result['amount'] || 0) / 100.0)}"
      else
        puts "\nâŒ Failed to create refund."
      end
    end

    desc "version", "Show version"
    def version
      puts "Clover Sandbox Simulator v1.0.0"
    end

    # ============================================
    # Database Management Commands (db: namespace)
    # ============================================

    desc "db SUBCOMMAND", "Database management commands"
    subcommand "db", Class.new(Thor) {
      namespace "db"

      desc "create", "Create the PostgreSQL database"
      def create
        db = CloverSandboxSimulator::Database
        url = db.database_url
        puts "Creating database..."
        db.create!(url)
        puts "Done."
      rescue CloverSandboxSimulator::Error => e
        puts "Error: #{e.message}"
        exit 1
      end

      desc "migrate", "Run pending migrations"
      def migrate
        db = CloverSandboxSimulator::Database
        url = db.database_url
        puts "Connecting and running migrations..."
        db.connect!(url)
        db.migrate!
        puts "Done."
      rescue CloverSandboxSimulator::Error => e
        puts "Error: #{e.message}"
        exit 1
      end

      desc "seed", "Seed the database with realistic data via FactoryBot"
      option :type, type: :string, desc: "Business type to seed (e.g. restaurant, retail_clothing). Seeds all if omitted."
      def seed
        db = CloverSandboxSimulator::Database
        url = db.database_url
        puts "Connecting and seeding..."
        db.connect!(url)
        bt = options[:type]&.to_sym
        result = db.seed!(business_type: bt)
        puts "Seeded: #{result[:business_types]} business types, #{result[:categories]} categories, #{result[:items]} items"
        puts "  (#{result[:created]} created, #{result[:found]} already existed)"
      rescue CloverSandboxSimulator::Error => e
        puts "Error: #{e.message}"
        exit 1
      end

      desc "reset", "Drop, create, migrate, and seed the database"
      option :type, type: :string, desc: "Business type to seed (e.g. restaurant). Seeds all if omitted."
      option :confirm, type: :boolean, desc: "Confirm destructive operation"
      def reset
        unless options[:confirm]
          puts "This will DROP and recreate the database. All data will be lost."
          puts "Run with --confirm to proceed."
          return
        end

        db = CloverSandboxSimulator::Database
        url = db.database_url

        puts "Dropping database..."
        db.drop!(url)

        puts "Creating database..."
        db.create!(url)

        puts "Connecting and running migrations..."
        db.connect!(url)
        db.migrate!

        puts "Seeding..."
        bt = options[:type]&.to_sym
        result = db.seed!(business_type: bt)
        puts "Seeded: #{result[:business_types]} business types, #{result[:categories]} categories, #{result[:items]} items"
        puts "Done."
      rescue CloverSandboxSimulator::Error => e
        puts "Error: #{e.message}"
        exit 1
      end
    }

    # ============================================
    # Audit & Reporting Commands
    # ============================================

    desc "summary", "Show daily summary for current merchant"
    option :date, type: :string, aliases: "-d", desc: "Date (YYYY-MM-DD, default: today)"
    def summary
      require_db_connection!

      date = options[:date] ? Date.parse(options[:date]) : Date.today
      merchant_id = CloverSandboxSimulator.configuration.merchant_id

      s = Models::DailySummary.for_merchant(merchant_id).on_date(date).first

      unless s
        puts "No summary found for merchant #{merchant_id} on #{date}."
        puts "Run 'simulate generate' to create orders first."
        return
      end

      puts "Daily Summary: #{date}"
      puts "=" * 50
      puts "  Merchant:      #{merchant_id}"
      puts "  Orders:        #{s.order_count}"
      puts "  Payments:      #{s.payment_count}"
      puts "  Refunds:       #{s.refund_count}"
      puts ""
      puts "  Revenue:       $#{'%.2f' % (s.total_revenue / 100.0)}"
      puts "  Tax:           $#{'%.2f' % (s.total_tax / 100.0)}"
      puts "  Tips:          $#{'%.2f' % (s.total_tips / 100.0)}"
      puts "  Discounts:     $#{'%.2f' % (s.total_discounts / 100.0)}"

      breakdown = s.breakdown || {}

      if breakdown["by_meal_period"]&.any?
        puts ""
        puts "  By Meal Period:"
        breakdown["by_meal_period"].each do |period, count|
          rev = breakdown.dig("revenue_by_meal_period", period) || 0
          puts "    #{period.ljust(15)} #{count.to_s.rjust(3)} orders  $#{'%.2f' % (rev / 100.0)}"
        end
      end

      if breakdown["by_dining_option"]&.any?
        puts ""
        puts "  By Dining Option:"
        breakdown["by_dining_option"].each do |opt, count|
          rev = breakdown.dig("revenue_by_dining_option", opt) || 0
          puts "    #{opt.ljust(15)} #{count.to_s.rjust(3)} orders  $#{'%.2f' % (rev / 100.0)}"
        end
      end

      if breakdown["by_tender"]&.any?
        puts ""
        puts "  By Tender:"
        breakdown["by_tender"].each do |tender, count|
          puts "    #{tender.ljust(20)} #{count} payments"
        end
      end
    end

    desc "audit", "Show recent API requests"
    option :limit, type: :numeric, aliases: "-l", default: 20, desc: "Number of requests to show (default: 20)"
    option :errors, type: :boolean, aliases: "-e", desc: "Show only error requests"
    def audit
      require_db_connection!

      scope = Models::ApiRequest.order(created_at: :desc)
      scope = scope.errors if options[:errors]
      requests = scope.limit(options[:limit])

      if requests.empty?
        label = options[:errors] ? "error " : ""
        puts "No #{label}API requests found."
        return
      end

      label = options[:errors] ? "Error " : ""
      puts "Recent #{label}API Requests (#{requests.size})"
      puts "=" * 80

      requests.each do |req|
        status_indicator = req.error_message ? "ERR" : "OK "
        ts = req.created_at.strftime("%H:%M:%S")
        duration = req.duration_ms ? "#{req.duration_ms}ms" : "N/A"

        puts "#{status_indicator} #{ts} #{req.http_method.ljust(6)} #{req.response_status || '---'} " \
             "#{duration.rjust(7)}  #{truncate_url(req.url, 50)}"

        if req.error_message
          puts "    Error: #{req.error_message[0..80]}"
        end
      end

      total = Models::ApiRequest.count
      errors = Models::ApiRequest.errors.count
      puts "\nTotal: #{total} requests, #{errors} errors"
    end

    desc "business_types", "List business types with category and item counts"
    def business_types
      require_db_connection!

      types = Models::BusinessType.all.order(:key)

      if types.empty?
        puts "No business types found. Run 'simulate db seed' first."
        return
      end

      puts "Business Types"
      puts "=" * 60
      puts "#{'Key'.ljust(20)} #{'Industry'.ljust(10)} #{'Categories'.rjust(10)} #{'Items'.rjust(8)}"
      puts "-" * 60

      total_cats = 0
      total_items = 0

      types.each do |bt|
        cat_count = bt.categories.count
        item_count = Models::Item.for_business_type(bt.key).count
        total_cats += cat_count
        total_items += item_count

        industry = bt.order_profile&.dig("industry") || "N/A"

        puts "#{bt.key.ljust(20)} #{industry.ljust(10)} #{cat_count.to_s.rjust(10)} #{item_count.to_s.rjust(8)}"
      end

      puts "-" * 60
      puts "#{'TOTAL'.ljust(20)} #{' '.ljust(10)} #{total_cats.to_s.rjust(10)} #{total_items.to_s.rjust(8)}"
    end

    # ============================================
    # Modifier Group Commands
    # ============================================

    desc "modifier_groups", "List all modifier groups"
    def modifier_groups
      configure_logging

      puts "ğŸ” Clover Sandbox Simulator - Modifier Groups"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new
      groups = services.inventory.get_modifier_groups

      if groups.empty?
        puts "No modifier groups found."
        puts "\nRun 'simulate setup' to create default modifier groups."
        return
      end

      puts "\nFound #{groups.size} modifier groups:\n\n"

      groups.each do |group|
        puts "ğŸ“¦ #{group['name']} (ID: #{group['id']})"
        puts "   Min Required: #{group['minRequired'] || 0}"
        puts "   Max Allowed:  #{group['maxAllowed'] || 'unlimited'}"

        modifiers = group.dig("modifiers", "elements") || []
        if modifiers.any?
          puts "   Modifiers:"
          modifiers.each do |mod|
            price = mod["price"] || 0
            price_str = price > 0 ? " (+$#{'%.2f' % (price / 100.0)})" : ""
            puts "      - #{mod['name']}#{price_str}"
          end
        end
        puts ""
      end
    end

    # ============================================
    # Order Type Commands
    # ============================================

    desc "order_types", "List all order types"
    def order_types
      configure_logging

      puts "ğŸ“ Clover Sandbox Simulator - Order Types"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new
      types = services.order_type.get_order_types

      if types.empty?
        puts "No order types found."
        puts "\nRun 'simulate setup' to create default order types."
        return
      end

      puts "\nFound #{types.size} order types:\n\n"

      puts "#{'Label'.ljust(20)} #{'ID'.ljust(20)} #{'Taxable'}"
      puts "-" * 50

      types.each do |ot|
        taxable = ot["taxable"] ? "Yes" : "No"
        puts "#{(ot['label'] || 'N/A').ljust(20)} #{ot['id'].ljust(20)} #{taxable}"
      end
    end

    # ============================================
    # Tax Rate Commands
    # ============================================

    desc "tax_rates", "List all tax rates"
    def tax_rates
      configure_logging

      puts "ğŸ’° Clover Sandbox Simulator - Tax Rates"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new
      rates = services.tax.get_tax_rates

      if rates.empty?
        puts "No tax rates found."
        puts "\nRun 'simulate setup' to create default tax rates."
        return
      end

      puts "\nFound #{rates.size} tax rates:\n\n"

      puts "#{'Name'.ljust(25)} #{'Rate'.rjust(8)} #{'Default'.ljust(10)} ID"
      puts "-" * 70

      rates.each do |rate|
        rate_pct = (rate["rate"] || 0) / 100_000.0
        default_str = rate["isDefault"] ? "Yes" : "No"
        puts "#{(rate['name'] || 'N/A').ljust(25)} #{'%.3f%' % rate_pct.rjust(8)} #{default_str.ljust(10)} #{rate['id']}"
      end
    end

    # ============================================
    # Service Charge Commands
    # ============================================

    desc "service_charges", "List all service charges"
    def service_charges
      configure_logging

      puts "ğŸ’µ Clover Sandbox Simulator - Service Charges"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      begin
        charges = services.service_charge.get_service_charges
      rescue StandardError => e
        puts "âš ï¸  Could not fetch service charges: #{e.message}"
        puts "\nNote: Service charges may need to be configured in the Clover dashboard."
        return
      end

      if charges.empty?
        puts "No service charges found."
        puts "\nNote: Service charges must be configured in the Clover dashboard."
        return
      end

      puts "\nFound #{charges.size} service charges:\n\n"

      puts "#{'Name'.ljust(25)} #{'Percentage'.rjust(12)} #{'Enabled'.ljust(10)} ID"
      puts "-" * 70

      charges.each do |charge|
        pct = charge["percentageDecimal"] ? "#{charge['percentageDecimal'] / 10_000.0}%" : "N/A"
        enabled = charge["enabled"] ? "Yes" : "No"
        puts "#{(charge['name'] || 'N/A').ljust(25)} #{pct.rjust(12)} #{enabled.ljust(10)} #{charge['id']}"
      end
    end

    # ============================================
    # Shift Commands
    # ============================================

    desc "shifts", "List active shifts"
    def shifts
      configure_logging

      puts "â° Clover Sandbox Simulator - Active Shifts"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      begin
        active_shifts = services.shift.get_active_shifts
      rescue StandardError => e
        puts "âš ï¸  Could not fetch shifts: #{e.message}"
        return
      end

      if active_shifts.empty?
        puts "No active shifts found."
        puts "\nUse 'simulate shift_clock_in -e EMPLOYEE_ID' to clock in an employee."
        return
      end

      puts "\nFound #{active_shifts.size} active shifts:\n\n"

      active_shifts.each do |shift|
        employee_name = shift.dig("employee", "name") || "Unknown"
        employee_id = shift.dig("employee", "id") || "N/A"
        in_time = shift["inTime"] ? Time.at(shift["inTime"] / 1000).strftime("%Y-%m-%d %H:%M") : "N/A"

        puts "ğŸ‘¤ #{employee_name}"
        puts "   Employee ID: #{employee_id}"
        puts "   Shift ID:    #{shift['id']}"
        puts "   Clocked In:  #{in_time}"
        puts ""
      end
    end

    desc "shift_clock_in", "Clock in an employee"
    option :employee_id, type: :string, aliases: "-e", required: true, desc: "Employee ID to clock in"
    def shift_clock_in
      configure_logging

      puts "â° Clover Sandbox Simulator - Clock In"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      puts "Clocking in employee: #{options[:employee_id]}"

      begin
        result = services.shift.clock_in(employee_id: options[:employee_id])

        if result && result["id"]
          puts "\nâœ… Employee clocked in successfully!"
          puts "   Shift ID:   #{result['id']}"
          puts "   In Time:    #{Time.at(result['inTime'] / 1000).strftime('%Y-%m-%d %H:%M')}"
        else
          puts "\nâŒ Failed to clock in employee."
        end
      rescue StandardError => e
        puts "\nâŒ Error: #{e.message}"
      end
    end

    desc "shift_clock_out", "Clock out an employee"
    option :employee_id, type: :string, aliases: "-e", required: true, desc: "Employee ID to clock out"
    def shift_clock_out
      configure_logging

      puts "â° Clover Sandbox Simulator - Clock Out"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      puts "Clocking out employee: #{options[:employee_id]}"

      begin
        result = services.shift.clock_out(employee_id: options[:employee_id])

        if result && result["id"]
          in_time = result["inTime"] ? Time.at(result["inTime"] / 1000) : nil
          out_time = result["outTime"] ? Time.at(result["outTime"] / 1000) : nil

          puts "\nâœ… Employee clocked out successfully!"
          puts "   Shift ID:   #{result['id']}"

          if in_time && out_time
            duration_minutes = ((out_time - in_time) / 60).round
            hours = duration_minutes / 60
            minutes = duration_minutes % 60
            puts "   Duration:   #{hours}h #{minutes}m"
          end
        else
          puts "\nâŒ Failed to clock out employee (no active shift found?)."
        end
      rescue StandardError => e
        puts "\nâŒ Error: #{e.message}"
      end
    end

    # ============================================
    # Cash Drawer Commands
    # ============================================

    desc "cash_open_drawer", "Open cash drawer with starting amount"
    option :amount, type: :numeric, aliases: "-a", default: 10000, desc: "Starting cash in cents (default: $100)"
    option :employee_id, type: :string, aliases: "-e", desc: "Employee ID (optional)"
    def cash_open_drawer
      configure_logging

      puts "ğŸ’µ Clover Sandbox Simulator - Open Cash Drawer"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      employee_id = options[:employee_id]
      unless employee_id
        employees = services.employee.get_employees
        employee_id = employees.first&.dig("id")
      end

      unless employee_id
        puts "âŒ No employee found. Create employees first with 'simulate setup'."
        return
      end

      puts "Opening drawer for employee: #{employee_id}"
      puts "Starting cash: $#{'%.2f' % (options[:amount] / 100.0)}"

      begin
        result = services.cash_event.open_drawer(employee_id: employee_id, amount: options[:amount])

        if result
          puts "\nâœ… Cash drawer opened!"
          puts "   Event ID: #{result['id'] || 'simulated'}"
          puts "   Amount:   $#{'%.2f' % (options[:amount] / 100.0)}"

          if result["simulated"]
            puts "\nâš ï¸  Note: Cash events may not be fully supported in sandbox."
          end
        else
          puts "\nâŒ Failed to open cash drawer."
        end
      rescue StandardError => e
        puts "\nâŒ Error: #{e.message}"
      end
    end

    desc "cash_close_drawer", "Close cash drawer"
    option :amount, type: :numeric, aliases: "-a", desc: "Final cash count in cents"
    option :employee_id, type: :string, aliases: "-e", desc: "Employee ID (optional)"
    def cash_close_drawer
      configure_logging

      puts "ğŸ’µ Clover Sandbox Simulator - Close Cash Drawer"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      employee_id = options[:employee_id]
      unless employee_id
        employees = services.employee.get_employees
        employee_id = employees.first&.dig("id")
      end

      unless employee_id
        puts "âŒ No employee found. Create employees first with 'simulate setup'."
        return
      end

      puts "Closing drawer for employee: #{employee_id}"

      begin
        result = services.cash_event.close_drawer(employee_id: employee_id, amount: options[:amount])

        if result
          puts "\nâœ… Cash drawer closed!"
          puts "   Event ID: #{result['id'] || 'simulated'}"

          if options[:amount]
            puts "   Final Count: $#{'%.2f' % (options[:amount] / 100.0)}"
          end

          if result["simulated"]
            puts "\nâš ï¸  Note: Cash events may not be fully supported in sandbox."
          end
        else
          puts "\nâŒ Failed to close cash drawer."
        end
      rescue StandardError => e
        puts "\nâŒ Error: #{e.message}"
      end
    end

    # ============================================
    # Gift Card Commands
    # ============================================

    desc "gift_cards", "List all gift cards and their balances"
    def gift_cards
      configure_logging

      puts "ğŸ Clover Sandbox Simulator - Gift Cards"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new
      cards = services.gift_card.fetch_gift_cards

      if cards.empty?
        puts "No gift cards found."
        puts "\nCreate one with: simulate gift_card_create --amount 5000"
        return
      end

      puts "\n#{'ID'.ljust(20)} #{'Card Number'.ljust(20)} #{'Balance'.rjust(12)} #{'Status'.ljust(10)}"
      puts "-" * 65

      total_balance = 0
      cards.each do |card|
        id = card["id"] || "N/A"
        number = mask_card_number(card["cardNumber"] || "Unknown")
        balance = card["balance"] || 0
        status = card["status"] || "UNKNOWN"

        total_balance += balance if status == "ACTIVE"

        balance_str = "$#{'%.2f' % (balance / 100.0)}"
        puts "#{id.ljust(20)} #{number.ljust(20)} #{balance_str.rjust(12)} #{status.ljust(10)}"
      end

      puts "-" * 65
      puts "Total Active Balance: $#{'%.2f' % (total_balance / 100.0)}"
      puts "\nâœ… Found #{cards.size} gift cards"
    end

    desc "gift_card_create", "Create a new gift card"
    option :amount, type: :numeric, aliases: "-a", required: true, desc: "Initial balance in cents (e.g., 5000 for $50)"
    option :card_number, type: :string, aliases: "-n", desc: "Optional 16-digit card number"
    def gift_card_create
      configure_logging

      puts "ğŸ Clover Sandbox Simulator - Create Gift Card"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      amount = options[:amount]
      card_number = options[:card_number]

      puts "Creating gift card with balance: $#{'%.2f' % (amount / 100.0)}"

      result = services.gift_card.create_gift_card(
        amount: amount,
        card_number: card_number
      )

      if result && result["id"]
        puts "\nâœ… Gift card created successfully!"
        puts "   ID:          #{result['id']}"
        puts "   Card Number: #{mask_card_number(result['cardNumber'])}"
        puts "   Balance:     $#{'%.2f' % ((result['balance'] || amount) / 100.0)}"
        puts "   Status:      #{result['status']}"
      else
        puts "\nâŒ Failed to create gift card"
      end
    end

    desc "gift_card_balance", "Check gift card balance"
    option :id, type: :string, aliases: "-i", required: true, desc: "Gift card ID"
    def gift_card_balance
      configure_logging

      puts "ğŸ Clover Sandbox Simulator - Gift Card Balance"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      card = services.gift_card.get_gift_card(options[:id])

      if card
        puts "\nGift Card Details:"
        puts "   ID:          #{card['id']}"
        puts "   Card Number: #{mask_card_number(card['cardNumber'])}"
        puts "   Balance:     $#{'%.2f' % ((card['balance'] || 0) / 100.0)}"
        puts "   Status:      #{card['status']}"
      else
        puts "\nâŒ Gift card not found: #{options[:id]}"
      end
    end

    desc "gift_card_reload", "Add balance to a gift card"
    option :id, type: :string, aliases: "-i", required: true, desc: "Gift card ID"
    option :amount, type: :numeric, aliases: "-a", required: true, desc: "Amount to add in cents"
    def gift_card_reload
      configure_logging

      puts "ğŸ Clover Sandbox Simulator - Reload Gift Card"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      gc_id = options[:id]
      amount = options[:amount]

      puts "Adding $#{'%.2f' % (amount / 100.0)} to gift card #{gc_id}"

      result = services.gift_card.reload_gift_card(gc_id, amount: amount)

      if result
        puts "\nâœ… Gift card reloaded successfully!"
        puts "   New Balance: $#{'%.2f' % ((result['balance'] || 0) / 100.0)}"
      else
        puts "\nâŒ Failed to reload gift card"
      end
    end

    desc "gift_card_redeem", "Redeem/use balance from a gift card"
    option :id, type: :string, aliases: "-i", required: true, desc: "Gift card ID"
    option :amount, type: :numeric, aliases: "-a", required: true, desc: "Amount to redeem in cents"
    def gift_card_redeem
      configure_logging

      puts "ğŸ Clover Sandbox Simulator - Redeem Gift Card"
      puts "=" * 50

      services = Services::Clover::ServicesManager.new

      gc_id = options[:id]
      amount = options[:amount]

      puts "Redeeming $#{'%.2f' % (amount / 100.0)} from gift card #{gc_id}"

      result = services.gift_card.redeem_gift_card(gc_id, amount: amount)

      if result[:success]
        puts "\nâœ… Redemption successful!"
        puts "   Amount Redeemed:   $#{'%.2f' % (result[:amount_redeemed] / 100.0)}"
        puts "   Remaining Balance: $#{'%.2f' % (result[:remaining_balance] / 100.0)}"

        if result[:shortfall] > 0
          puts "   âš ï¸  Shortfall:       $#{'%.2f' % (result[:shortfall] / 100.0)} (insufficient balance)"
        end
      else
        puts "\nâŒ Redemption failed: #{result[:message]}"
      end
    end

    private

    def mask_card_number(card_number)
      return card_number if card_number.nil? || card_number.length < 8

      "#{card_number[0..3]}********#{card_number[-4..]}"
    end

    def require_db_connection!
      url = Database.database_url
      Database.connect!(url) unless Database.connected?
    rescue Error => e
      puts "Database not available: #{e.message}"
      puts "Run 'simulate db create && simulate db migrate' first."
      exit 1
    end

    def truncate_url(url, max_length)
      return url if url.nil? || url.length <= max_length

      "...#{url[-(max_length - 3)..]}"
    end

    def configure_logging
      config = CloverSandboxSimulator.configuration

      if options[:verbose]
        config.logger.level = Logger::DEBUG
      else
        config.logger.level = Logger::INFO
      end

      # Load specific merchant if specified
      if options[:merchant]
        config.load_merchant(merchant_id: options[:merchant])
      elsif options[:merchant_index]
        config.load_merchant(index: options[:merchant_index])
      end

      puts "Using merchant: #{config.merchant_name} (#{config.merchant_id})"
    end

    def print_order_summary(orders)
      return if orders.empty?

      total_revenue = 0
      total_tips = 0
      total_tax = 0

      orders.each do |order|
        next unless order && order["payments"]&.dig("elements")

        order["payments"]["elements"].each do |payment|
          total_revenue += payment["amount"] || 0
          total_tips += payment["tipAmount"] || 0
          total_tax += payment["taxAmount"] || 0
        end
      end

      puts "\nğŸ“Š Summary:"
      puts "   Revenue:  $#{total_revenue / 100.0}"
      puts "   Tips:     $#{total_tips / 100.0}"
      puts "   Tax:      $#{total_tax / 100.0}"
      puts "   Total:    $#{(total_revenue + total_tips + total_tax) / 100.0}"
    end
  end
end

CloverSandboxSimulator::CLI.start(ARGV)
